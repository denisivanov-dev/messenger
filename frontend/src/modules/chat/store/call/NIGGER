import { defineStore } from 'pinia'
import { ref, computed, watch } from 'vue'
import { useChatStore } from './chatStore'
import { useAuthStore } from '../../auth/store/authStore'
import { sendMessage } from '../api/chatApi'

export const useCallStore = defineStore('call', () => {
  const chatStore = useChatStore()
  const authStore = useAuthStore()

  // --- Core state ---
  const peerConnection = ref(null)
  const localStream = ref(null)
  const remoteStream = ref(null)
  const inCall = ref(false)
  const isCalling = ref(false)
  const incomingCallFrom = ref(null)
  const callMembers = ref({})
  const hasJoined = ref(false)
  const remoteAudioElement = ref(null)
  const pendingCandidates = []

  // --- Mic settings (persisted) ---
  // enabled: true -> микрофон ВКЛ; false -> muted
  const micSettings = ref({
    enabled: true,
    deviceId: null,
  })

  const isMuted = computed(() => !micSettings.value.enabled)

  const micKeyForUser = () => `call:mic:${String(authStore.getUserId)}`

  function loadMicSettings() {
    try {
      const raw = localStorage.getItem(micKeyForUser())
      if (raw) {
        const parsed = JSON.parse(raw)
        micSettings.value = {
          enabled: typeof parsed.enabled === 'boolean' ? parsed.enabled : true,
          deviceId: parsed.deviceId ?? null,
        }
      }
    } catch {}
  }

  function saveMicSettings() {
    try {
      localStorage.setItem(micKeyForUser(), JSON.stringify(micSettings.value))
    } catch {}
  }

  function applyMicStateToLocalStream() {
    if (!localStream.value) return
    const shouldEnable = micSettings.value.enabled
    localStream.value.getAudioTracks().forEach(track => {
      track.enabled = shouldEnable
    })
  }

  watch(localStream, () => {
    applyMicStateToLocalStream()
  })

  loadMicSettings()

  // --- Media / ICE ---
  const audioBaseConstraints = {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true,
    channelCount: 2,
    sampleRate: 48000,
    sampleSize: 16,
  }

  const servers = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      {
        urls: 'turn:46.109.9.240:3478',
        username: 'test',
        credential: '1234'
      }
    ]
  }

  function setMemberStatus(userId, status) {
    const id = String(userId)
    callMembers.value[id] = status
  }

  function removeMember(userId) {
    const id = String(userId)
    delete callMembers.value[id]
  }

  function getMyId() {
    return String(authStore.getUserId)
  }

  // ================= Call Flow =================

  async function startRequestCall() {
    const myId = getMyId()
    inCall.value = true
    isCalling.value = true
    hasJoined.value = true
    callMembers.value = {
      [myId]: 'joined',
      [String(chatStore.receiverID)]: 'calling'
    }

    sendMessage({
      type: 'start_call',
      chat_type: 'private',
      receiver_id: chatStore.receiverID
    })
  }

  function cancelRequestCall() {
    if (!isCalling.value) return

    sendMessage({
      type: 'cancel_call',
      chat_type: 'private',
      receiver_id: chatStore.receiverID
    })

    resetCallState()
  }

  function handleIncomingCall(fromUserID) {
    incomingCallFrom.value = fromUserID
    setMemberStatus(fromUserID, 'joined')
  }

  function handleCallCanceled(fromUserID) {
    if (incomingCallFrom.value === fromUserID) {
      incomingCallFrom.value = null
      callMembers.value = {}
    }
  }

  async function acceptCall(fromUserID) {
    incomingCallFrom.value = null
    hasJoined.value = true
    setMemberStatus(getMyId(), 'joined')

    sendMessage({
      type: 'call_answer',
      chat_type: 'private',
      receiver_id: fromUserID,
      accepted: true
    })

    await startCall(fromUserID, false)
  }

  function declineCall(fromUserID) {
    sendMessage({
      type: 'call_answer',
      chat_type: 'private',
      receiver_id: fromUserID,
      accepted: false
    })
    incomingCallFrom.value = null
  }

  async function handleCallAnswer(fromUserID, accepted) {
    isCalling.value = false

    if (!accepted) {
      delete callMembers.value[String(fromUserID)]
      return
    }

    callMembers.value[String(fromUserID)] = 'joined'
    await startCall(fromUserID, true)
  }

  async function startCall(targetID, isCaller) {
    const constraints = {
      audio: {
        ...audioBaseConstraints,
        ...(micSettings.value.deviceId ? { deviceId: { exact: micSettings.value.deviceId } } : {})
      }
    }

    localStream.value = await navigator.mediaDevices.getUserMedia(constraints)
    applyMicStateToLocalStream()

    peerConnection.value = new RTCPeerConnection({ iceServers: servers.iceServers })
    remoteStream.value = new MediaStream()

    localStream.value.getTracks().forEach(track => {
      peerConnection.value.addTrack(track, localStream.value)
    })

    peerConnection.value.ontrack = event => {
      event.streams[0].getTracks().forEach(track => {
        remoteStream.value.addTrack(track)
      })
      if (remoteAudioElement.value) {
        remoteAudioElement.value.srcObject = event.streams[0]
        remoteAudioElement.value.play().catch(err => console.warn('[ontrack] play error:', err))
      }
    }

    peerConnection.value.onicecandidate = e => {
      if (e.candidate) {
        sendMessage({
          type: 'ice_candidate',
          chat_type: 'private',
          receiver_id: targetID,
          candidate: e.candidate
        })
      }
    }

    if (isCaller) {
      const offer = await peerConnection.value.createOffer()
      await peerConnection.value.setLocalDescription(offer)

      sendMessage({
        type: 'webrtc_offer',
        chat_type: 'private',
        receiver_id: targetID,
        offer
      })
    }

    inCall.value = true
  }

  async function handleOffer(from, offer) {
	if (!peerConnection.value) {
		peerConnection.value = new RTCPeerConnection({ iceServers: servers.iceServers })
		remoteStream.value = new MediaStream()

		peerConnection.value.ontrack = event => {
		event.streams[0].getTracks().forEach(track => remoteStream.value.addTrack(track))
		if (remoteAudioElement.value) {
			remoteAudioElement.value.srcObject = event.streams[0]
			remoteAudioElement.value.play().catch(console.warn)
		}
		}

		peerConnection.value.onicecandidate = e => {
		if (e.candidate) {
			sendMessage({
			type: 'ice_candidate',
			chat_type: 'private',
			receiver_id: from,
			candidate: e.candidate
			})
		}
		}
	}

	const pc = peerConnection.value

	await pc.setRemoteDescription(new RTCSessionDescription(offer))

	const constraints = {
		audio: {
		...audioBaseConstraints,
		...(micSettings.value.deviceId ? { deviceId: { exact: micSettings.value.deviceId } } : {})
		}
	}
	if (!localStream.value) {
		localStream.value = await navigator.mediaDevices.getUserMedia(constraints)
		applyMicStateToLocalStream()
		localStream.value.getTracks().forEach(track => pc.addTrack(track, localStream.value))
	}

	if (pc.signalingState !== 'have-remote-offer') return

	const answer = await pc.createAnswer()
	await pc.setLocalDescription(answer)

	sendMessage({
		type: 'webrtc_answer',
		chat_type: 'private',
		receiver_id: from,
		answer
	})

	for (const cand of pendingCandidates) {
		try { await pc.addIceCandidate(cand) } catch (err) {
		console.error('[handleOffer] addIceCandidate error:', err)
		}
	}
	pendingCandidates.length = 0

	inCall.value = true
	hasJoined.value = true
	setMemberStatus(getMyId(), 'joined')
  }

  async function handleAnswer(answer) {
    await peerConnection.value.setRemoteDescription(new RTCSessionDescription(answer))
    for (const cand of pendingCandidates) {
      try {
        await peerConnection.value.addIceCandidate(cand)
      } catch (err) {
        console.error('[handleAnswer] addIceCandidate error:', err)
      }
    }
    pendingCandidates.length = 0
  }

  async function handleIceCandidate(candidate) {
    if (!peerConnection.value || !peerConnection.value.remoteDescription) {
      pendingCandidates.push(candidate)
      return
    }
    try {
      await peerConnection.value.addIceCandidate(candidate)
    } catch (err) {
      console.error('[handleIceCandidate] addIceCandidate error:', err)
    }
  }

  async function joinCall() {
    const myId = getMyId()
    if (!callMembers.value[myId]) {
      setMemberStatus(myId, 'joined')
    }

    hasJoined.value = true
    inCall.value = true

    sendMessage({
      type: 'join_call',
      chat_type: 'private',
      receiver_id: chatStore.receiverID
    })

    await startCall(chatStore.receiverID, false)
  }

  function handleJoinCall(userId) {
    setMemberStatus(userId, 'joined')

    if (hasJoined.value && peerConnection.value) {
      startCall(userId, true)
    }
  }

  function leaveCall() {
    const myId = getMyId()

    if (isCalling.value) {
      cancelRequestCall()
      return
    }

    removeMember(myId)
    hasJoined.value = false

    sendMessage({
      type: 'leave_call',
      chat_type: 'private',
      receiver_id: chatStore.receiverID
    })

    if (Object.keys(callMembers.value).length === 0) {
      resetCallState()
    } else {
      endCall()
    }
  }

  function endCall() {
    peerConnection.value?.close()
    peerConnection.value = null

    localStream.value?.getTracks().forEach(track => track.stop())
    remoteStream.value?.getTracks().forEach(track => track.stop())

    localStream.value = null
    remoteStream.value = null
    inCall.value = false
    isCalling.value = false

    if (remoteAudioElement.value) {
      remoteAudioElement.value.pause()
      remoteAudioElement.value.srcObject = null
    }
  }

  function resetCallState() {
    inCall.value = false
    isCalling.value = false
    hasJoined.value = false
    incomingCallFrom.value = null
    callMembers.value = {}
    endCall()
  }

  // ================= Mic control =================

  function toggleMute() {
    micSettings.value.enabled = !micSettings.value.enabled
    saveMicSettings()

    if (!localStream.value) return
    localStream.value.getAudioTracks().forEach(track => {
      track.enabled = micSettings.value.enabled
    })
  }

  async function setMicDevice(deviceId) {
    micSettings.value.deviceId = deviceId
    saveMicSettings()

    if (!inCall.value) return

    const constraints = {
      audio: {
        ...audioBaseConstraints,
        ...(deviceId ? { deviceId: { exact: deviceId } } : {})
      }
    }

    const newStream = await navigator.mediaDevices.getUserMedia(constraints)

    newStream.getAudioTracks().forEach(t => (t.enabled = micSettings.value.enabled))

    if (peerConnection.value) {
      const senders = peerConnection.value.getSenders().filter(s => s.track && s.track.kind === 'audio')
      const newTrack = newStream.getAudioTracks()[0]
      if (newTrack) {
        if (senders.length > 0) {
          await senders[0].replaceTrack(newTrack)
        } else {
          peerConnection.value.addTrack(newTrack, newStream)
        }
      }
    }

    localStream.value?.getTracks().forEach(t => t.stop())
    localStream.value = newStream
  }

  return {
    // state
    inCall,
    localStream,
    remoteStream,
    incomingCallFrom,
    callMembers,
    isCalling,
    hasJoined,
    remoteAudioElement,

    // mic
    micSettings,
    isMuted,       // computed для UI
    toggleMute,
    setMicDevice,

    // call flow
    startRequestCall,
    cancelRequestCall,
    acceptCall,
    declineCall,
    leaveCall,
    joinCall,

    handleIncomingCall,
    handleCallCanceled,
    handleCallAnswer,
    handleOffer,
    handleAnswer,
    handleIceCandidate,
    handleJoinCall,
    endCall,
  }
})